#include "arduino_secrets.h"
/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/edb6a3ea-c106-4669-a2ed-9437959980ba 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  CloudSwitch fan;
  CloudSwitch bedroom_light;
  CloudTemperatureSensor temperature;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#define BLYNK_TEMPLATE_ID "BLYNK_TEMPLATE_ID"
#define BLYNK_TEMPLATE_NAME "BLYNK_TEMPLATE_NAME"
#define BLYNK_AUTH_TOKEN "BLYNK_AUTH_TOKEN"
#define BLYNK_PRINT Serial

#include "thingProperties.h"
#include <WiFi.h>
#include <PubSubClient.h>
#include <BlynkSimpleEsp32.h>
#include <DHT.h>
#include <ESP32Servo.h>

WiFiClient espClient;
PubSubClient client(espClient);
BlynkTimer timer;

char auth[] = "BLYNK_AUTH_TOKEN";
char ssid[] = "WIFI_SSID";
char pass[] = "WIFI_PASSWORD";

// HiveMQ
const char* mqtt_server = "broker.mqtt-dashboard.com";
const char* unique_identifier = "HiveMQ_CLIENTID";


// Define the pins for RFID
#define SS_PIN 5     // Pin SS untuk ESP32
#define RST_PIN 22   // Pin RST untuk ESP32
#define SCK_PIN 18   // SCK pin untuk ESP32
#define MISO_PIN 21  // MISO pin untuk ESP32
#define MOSI_PIN 19  // MOSI pin untuk ESP32
#define VPIN_RAIN V1
#define VPIN_GAS V4

// define the GPIO connected with Sensors & Buzzer
#define MQ2_SENSOR 35
#define RAIN_SENSOR 34
#define BUZZER 32
// Relay connected to fan
#define FAN_PIN 12
//Connect Out pin to D15 in NODE MCU
#define DHTPIN 27
#define DHTTYPE DHT22
DHT dht(DHTPIN, DHTTYPE);


// Define LED pin
#define BEDROOM_LED 4  // Adjust this to the pin connected to your LED
#define TOILET_LED 2   // Adjust this to the pin connected to your LED


Servo clothesServo;   // Servo for clothes
Servo mainDoorServo;  // Servo for main door
int count = 0;
int CLOSE_ANGLE = 180;  // The closing angle of the servo motor arm
int OPEN_ANGLE = 70;    // The opening angle of the servo motor arm
int MQ2_SENSOR_Value = 0;
int RAIN_SENSOR_Value = 0;
int ir = 15;  // IR sensor pin
int x;

bool gateOpen = true;                         // Keeps track of whether the gate is open or closed
bool isFanOn = false;                         // Track the fan state for hysteresis
bool fanOverride = false;                     // Flag to track fan override state
bool ledOverride = false;                     // Flag to track led override state
bool blynkLedState = false;                   // Track the Blynk led switch state
bool blynkFanState = false;                   // Track the Blynk fan switch state
float temperatureThresholdOn = 31.0;          // Temperature threshold
float temperatureThresholdOff = 25.0;         // Temperature threshold
unsigned long lastTemperatureUpdate = 0;      // Store last update time
const long temperatureUpdateInterval = 2000;  // Update every 2 seconds

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(115200);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500);
  WiFi.disconnect(true, true);  // Clear saved WiFi data
  // Initialize WiFi connection
  setup_wifi();  // Function to connect to WiFi

  // Initialize the MQTT client
  client.setServer(mqtt_server, 1883);  // Set the MQTT broker and port
  client.setCallback(callback);         // Set the MQTT message handler function

  Blynk.begin(auth, ssid, pass);
  dht.begin();

  pinMode(ir, INPUT);

  pinMode(BEDROOM_LED, OUTPUT);
  digitalWrite(BEDROOM_LED, HIGH);  // Initialize BEDROOM_LED as OFF

  pinMode(TOILET_LED, OUTPUT);
  digitalWrite(TOILET_LED, LOW);  // Initialize TOILET_LED as OFF

  pinMode(FAN_PIN, OUTPUT);
  digitalWrite(FAN_PIN, HIGH);  // Start with fan off

  pinMode(MQ2_SENSOR, INPUT);
  pinMode(RAIN_SENSOR, INPUT);
  pinMode(BUZZER, OUTPUT);

  clothesServo.attach(33);   // Attach clothes servo to pin 33
  mainDoorServo.attach(23);  // Attach main door servo to pin 23

  delay(2000);  // Give time for the sensor to stabilize

  // Set up a timer to check the IR sensor every 500 ms
  timer.setInterval(500L, checkIRSensor);
  timer.setInterval(2000L, handleGasSensor);
  timer.setInterval(2000L, handleRainSensor);

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
}

void loop() {
  if (!client.connected()) {
    reconnect();
  }
  ArduinoCloud.update();
  // Your code here
  client.loop();  // Keep the MQTT client connected and responsive
  Blynk.run();
  timer.run();  // Run the timer 

  // Check if it's time to update temperature
  if (millis() - lastTemperatureUpdate >= temperatureUpdateInterval) {
    lastTemperatureUpdate = millis();  // Reset timer
    onTemperatureChange();  // Manually trigger temperature update
  }
}


/*
  Since LivingRoomLight is READ_WRITE variable, onLivingRoomLightChange() is
  executed every time a new value is received from IoT Cloud.
*/
BLYNK_WRITE(V2) {
  int blynkLedState = param.asInt();
  bedroom_light = blynkLedState;  // Update light state globally

  // Apply change to actual LED
  digitalWrite(BEDROOM_LED, bedroom_light ? LOW : HIGH);
  Serial.println(bedroom_light ? "Bedroom Light turned ON from Blynk" : "Bedroom Light turned OFF from Blynk");
}

void onBedroomLightChange() {
  Serial.print("Cloud Bedroom Light Control Updated: ");
  Serial.println(bedroom_light ? "ON" : "OFF");

  // Apply change to actual LED
  digitalWrite(BEDROOM_LED, bedroom_light ? LOW : HIGH);
  Serial.println(bedroom_light ? "Bedroom Light turned ON from Cloud" : "Bedroom Light turned OFF from Cloud");

  // Sync with Blynk
  Blynk.virtualWrite(V2, bedroom_light ? 1 : 0);
}


/*
  Since Fan is READ_WRITE variable, onFanChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onFanChange() {
  Serial.print("Cloud Fan Control Updated: ");
  Serial.println(fan ? "ON" : "OFF");

  // Manually control fan based on the Cloud fan state, regardless of temperature
  fanOverride = fan;  // Set fanOverride to the value from the Cloud

  if (fanOverride) {
    digitalWrite(FAN_PIN, LOW);  // Turn fan ON
    Blynk.virtualWrite(V3, 1);  // Set Blynk switch to ON if fan is ON
    Serial.println("Fan turned ON manually from cloud");
  } else {
    digitalWrite(FAN_PIN, HIGH);  // Turn fan OFF
    Blynk.virtualWrite(V3, 0);  // Set Blynk switch to OFF if fan is OFF
    Serial.println("Fan turned OFF manually from cloud");
  }

  // Synchronize Blynk with Cloud if fan is manually controlled
  if (!fanOverride) {  // Only update Blynk if no manual override
    Blynk.virtualWrite(V3, fan ? 1 : 0);
  }
}

void pushFanStateToCloud() {
  Serial.print("Pushing Fan State to Cloud: ");
  Serial.println(fan ? "ON" : "OFF");

  // Manually trigger the cloud update
  ArduinoCloud.update();  // Ensures fan state is sent to Google Cloud
}


/*
  Since Temperature is READ_WRITE variable, onTemperatureChange() is
  executed every time a new value is received from IoT Cloud.
*/

void onTemperatureChange() {
  float h = dht.readHumidity();
  float t = dht.readTemperature();

  if (isnan(h) || isnan(t)) {
    Serial.println("Failed to read from DHT sensor!");
    return;
  }

  // Send data to Blynk
  Blynk.virtualWrite(V0, t);
  // Only update the cloud temperature variable
  temperature = t;  // Sync temperature with cloud
  Serial.print("Cloud Temperature Updated: ");
  Serial.println(temperature);

  // Use temperature to control the fan if Blynk override is OFF
  if (!fanOverride) {
    if (temperature > temperatureThresholdOn && !isFanOn) {
      digitalWrite(FAN_PIN, LOW);  // Turn fan ON
      isFanOn = true;              // Update fan state

      if (fan != true) {           // Only update if value is different
        fan = true;                // Update cloud fan state
        delay(500);                 // Small delay to ensure cloud processes change
        pushFanStateToCloud();      // Force update to cloud
      }

      Blynk.virtualWrite(V3, 1);   // Set Blynk switch to ON
      Serial.println("Fan turned ON due to temperature change");
    } else if (temperature < temperatureThresholdOff && isFanOn) {
      digitalWrite(FAN_PIN, HIGH);  // Turn fan OFF
      isFanOn = false;              // Update fan state

      if (fan != false) {           // Only update if value is different
        fan = false;                // Update cloud fan state
        delay(500);                 // Small delay to ensure cloud processes change
        pushFanStateToCloud();      // Force update to cloud
      }

      Blynk.virtualWrite(V3, 0);   // Set Blynk switch to OFF
      Serial.println("Fan turned OFF due to temperature change");
    }
  }
}


// Blynk write function for virtual pin V3 (linked to the fan)
BLYNK_WRITE(V3) {
  blynkFanState = param.asInt();  // Update blynkSwitchState based on Blynk switch (0 = off, 1 = on)
  fan = blynkFanState;    // Set fanOverride flag based on switch

  digitalWrite(FAN_PIN, fan ? LOW : HIGH);

  // Synchronize the Cloud state with Blynk when fan is controlled by Blynk
  if (!fanOverride) {
    Blynk.virtualWrite(V3, blynkFanState);  // Sync with cloud if fan is manually controlled from Blynk
  } else {
    Blynk.virtualWrite(V3, blynkFanState);  // Ensure the Blynk state matches the manual control
  }

  Serial.print("Fan Override: ");
  Serial.println(fan ? "ON" : "OFF");
}

void handleGasSensor() {
  // Read and map MQ2 sensor value to a percentage
  MQ2_SENSOR_Value = map(analogRead(MQ2_SENSOR), 0, 4095, 0, 100);

  // Trigger the buzzer if gas concentration is above threshold
  if (MQ2_SENSOR_Value > 15){//50) {
    tone(BUZZER, 1000);
    delay(1500);
    tone(BUZZER, 1000);
    delay(500);
    noTone(BUZZER);
    delay(1000);

    // Log event and update Blynk with gas detected message
    Blynk.logEvent("gas", "Gas Detected!");
  }

  // Send gas sensor data to Blynk
  Blynk.virtualWrite(VPIN_GAS, MQ2_SENSOR_Value);
}

void handleRainSensor() {
  // Read rain sensor value
  RAIN_SENSOR_Value = digitalRead(RAIN_SENSOR);

  if (RAIN_SENSOR_Value == 0) {  // Rain detected
    Serial.println("Rain detected!");

    // Log event and update Blynk with rain detected message
    Blynk.logEvent("rain", "Rain Detected!");
    Blynk.virtualWrite(VPIN_RAIN, "Rain Detected!");

    // Close the gate only if it's open
    // Open the gate only if it's closed
    if (!gateOpen) {
      for (int pos = 0; pos <= 90; pos += 1) {
        clothesServo.write(pos);
        delay(15);
      }
      gateOpen = true;  // Update the gate state to open
      Serial.println("Gate open");
    }
  } else {  // No rain detected
    //Serial.println("No rain detected.");
    Blynk.virtualWrite(VPIN_RAIN, "No Rain Detected.");

    if (gateOpen) {
      for (int pos = 90; pos >= 0; pos -= 1) {
        clothesServo.write(pos);
        delay(15);
      }
      gateOpen = false;  // Update the gate state to closed
      Serial.println("Gate closed");
    }
  }
}

// Function to check the IR sensor and update LED based on IR sensor and Blynk switch state
void checkIRSensor() {
  x = digitalRead(ir);  // Read IR sensor

  // Control LED based on IR sensor
  if (x == 0) {                      // If IR sensor is triggered (obstacle detected)
    digitalWrite(TOILET_LED, HIGH);  // Turn LED ON

  } else {                          // No obstacle detected
    digitalWrite(TOILET_LED, LOW);  // Turn LED OFF
  }
}


void reconnect() {
  // Loop until we're reconnected
  while (!client.connected()) {
    Serial.print("Attempting MQTT connection...");
    // Attempt to connect
    String clientId = "HiveMQ_CLIENTID";
    clientId += String(random(0xffff), HEX);
    // Attempt to connect
    if (client.connect(clientId.c_str())) {
      Serial.println("connected");
      // Subscribe
      client.subscribe("open_door");
    } else {
      Serial.print("failed, rc=");
      Serial.print(client.state());
      Serial.println(" try again in 5 seconds");
      // Wait 5 seconds before retrying
      delay(5000);
    }
  }
}


void setup_wifi() {
  delay(10);
  // We start by connecting to a WiFi network
  Serial.println();
  Serial.println(WiFi.macAddress());

  Serial.print("Connecting to ");
  Serial.println(ssid);

  WiFi.begin(ssid, pass);

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }

  Serial.println("");
  Serial.println("WiFi connected");
  Serial.println("IP address: ");
  Serial.println(WiFi.localIP());
}

void callback(char* topic, byte* payload, unsigned int length) {
  String message;
  for (int i = 0; i < length; i++) {
    message += (char)payload[i];
  }

  if (String(topic) == "open_door" && message == "open") {
    // Open the gate gradually
    for (int pos = OPEN_ANGLE; pos <= CLOSE_ANGLE; pos += 1) {
      mainDoorServo.write(pos);
      delay(15);
    }

    delay(1000);  // Keep the gate open for a moment

    // Close the gate gradually
    for (int pos = CLOSE_ANGLE; pos >= OPEN_ANGLE; pos -= 1) {
      mainDoorServo.write(pos);
      delay(15);
    }
  } else {
    Blynk.logEvent("unauthorized_face_detected", "Unauthorized Face Detected!");
    for (int i = 0; i < 10; i++) {  // Beep 10 times
      tone(BUZZER, 1000);           // Start the buzzer
      delay(300);                   // Beep duration
      noTone(BUZZER);               // Stop the buzzer
      delay(200);                   // Pause between beeps
    }
  }
}
